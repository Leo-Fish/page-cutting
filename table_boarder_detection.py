# -*- coding: utf-8 -*-
"""Table_boarder_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QxZAon7pTGA-H_HeAqxGTAP7UbrsYOe9

# Extracting Tables From PDFs

## Installing Dependencies
"""

!pip install -U layoutparser

# Install Detectron2 for using DL Layout Detection Model
# Please make sure the PyTorch version is compatible with
# the installed Detectron2 version.
!pip install 'git+https://github.com/facebookresearch/detectron2.git@v0.4#egg=detectron2'

# Install the ocr components when necessary
# !pip install layoutparser[ocr]

!pip install tesseract

!pip install pillow==9.5

!pip install poppler-utils

!pip install google-api-core==1.9
!pip install google-cloud-vision

# !pip install PyMuPDF

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/

!pwd

"""# Image processing"""

from pdf2image import convert_from_path
from PIL import Image
from google.colab.patches import cv2_imshow  # Import cv2_imshow from google.colab.patches
import cv2
import sklearn
from sklearn.linear_model import LinearRegression
import numpy as np


# pdf_file_path = "/content/test.pdf"

# images = convert_from_path(pdf_file_path, fmt="png")
# image = images[0]
# image.save("/content/output.png", "png")

# image = cv2.imread("/content/output.png")
# cv2_imshow(image)

image = cv2.imread("/content/test2.png")
cv2_imshow(image)
cv2.waitKey(0)
# image = cv2.imread("/content/test.png")

import layoutparser as lp

# PubLayNet
model = lp.Detectron2LayoutModel('lp://PubLayNet/mask_rcnn_R_50_FPN_3x/config',extra_config=["MODEL.ROI_HEADS.SCORE_THRESH_TEST", 0.8],
                                 label_map={0: "Text", 1: "Title", 2: "List", 3:"Table", 4:"Figure"})

# model = lp.Detectron2LayoutModel('lp://PubLayNet/mask_rcnn_X_101_32x8d_FPN_3x/config',extra_config=["MODEL.ROI_HEADS.SCORE_THRESH_TEST", 0.6],
#                                  label_map={0: "Text", 1: "Title", 2: "List", 3:"Table", 4:"Figure"})
layout = model.detect(image) # You need to load the image somewhere else, e.g., image = cv2.imread(...)

layout = lp.Layout([b for b in layout if b.type!='Title'])

lp.draw_box(image, layout, box_width=3, color_map={}, show_element_type=True, id_text_color='white', id_text_background_color='black')

def read_rectangles(layout):
  rectangles=[]
  for rectangle in layout:
    rectangles.append(rectangle.coordinates)
  return rectangles

rectangles=read_rectangles(layout)
rectangles

def average(rectangles):
  center=[]
  for i in rectangles:
    center.append((i[0]+i[2])/2)
  return center

def process_list(numbers):
    result = []
    indices = list(range(len(numbers)))

    while indices:
        chosen_idx = indices[0]
        chosen = numbers[chosen_idx]
        to_move = [i for i in indices if abs(numbers[i] - chosen) < 15]
        result.append(to_move)
        indices = [i for i in indices if i not in to_move]

    return result, numbers

center=average(rectangles)
index_groups, numbers = process_list(center)

print(index_groups)
for group in index_groups:
    print([numbers[i] for i in group])
print()
# Sort by length descending
index_groups.sort(key=len, reverse=True)

# Keep only top 2
index_groups = index_groups[:2]

index_groups = sorted(index_groups, key=lambda x: numbers[x[0]])

print(index_groups)

block1=[rectangles[i] for i in index_groups[0]]
block2=[rectangles[i] for i in index_groups[1]]

block1=[[i[2],i[3]] for i in block1]
block1

block2=[[i[0],i[1]] for i in block2]
block2

coords = block1+block2

# Extract x, y
x = [c[0] for c in coords]
y = [c[1] for c in coords]

# Fit RANSAC model to x coordinates
x = np.array(x).reshape(-1,1)
model = sklearn.linear_model.RANSACRegressor()
model.fit(x, x)

# Get inlier mask for x
inlier_mask = model.inlier_mask_

# Remove x outliers
x = [x[i] for i in range(len(x)) if inlier_mask[i]]

# Keep all y values
y = [y[i] for i in range(len(y))]

# Perform RANSAC regression

coords = block1+block2

# Extract x, y
x = [c[0] for c in coords]
y = [c[1] for c in coords]
print(x)

model = sklearn.linear_model.RANSACRegressor()
model.fit(np.array(x).reshape(-1,1), y)

# Extract inlier points
inlier_mask = model.inlier_mask_
x = [x[i] for i in range(len(x)) if inlier_mask[i]]
y = [y[i] for i in range(len(y)) if inlier_mask[i]]

print(x)

cv2.circle(image, (int(1150), int(1500)), 5, (0, 0, 255), -1)
cv2_imshow(image)
cv2.waitKey(0)

m, b = np.polyfit(x, y, 1)

for coord in coords:
  xx = coord[0]
  yy = coord[1]
  cv2.circle(image, (int(xx), int(yy)), 5, (0, 255, 0), -1)
  print(xx,yy)

# Draw fitted line
# cv2.line(image, (0,int(b)), (1000,int(m*512+b)), (0,255,0), 2)

# Display image
cv2_imshow(image)
cv2.waitKey(0)

block1

import numpy as np
import cv2

# Example coordinates as list of lists

# Convert to NumPy array
block1 = np.array(block1)

# Fit line and generate points (same as before)
coeffs1 = np.polyfit(block1[:,0], block1[:,1], 1)
line_fn = np.poly1d(coeffs1)
x = np.linspace(600, 900, 100)
y = line_fn(x)
line_pts = np.stack((x, y)).T.astype(np.int32)

# Draw on existing image
cv2.polylines(image, [line_pts], False, (200,0,0), 2)

block2 = np.array(block2)

# Fit line and generate points (same as before)
coeffs2 = np.polyfit(block2[:,0], block2[:,1], 1)
line_fn = np.poly1d(coeffs2)
x = np.linspace(600, 900, 100)
y = line_fn(x)
line_pts = np.stack((x, y)).T.astype(np.int32)

# Draw on existing image
cv2.polylines(image, [line_pts], False, (200,0,0), 2)

line_fn = np.poly1d(coeffs1+coeffs2)
x = np.linspace(600, 900, 100)
y = line_fn(x)
line_pts = np.stack((x, y)).T.astype(np.int32)

# Draw on existing image
cv2.polylines(image, [line_pts], False, (0,0,255), 2)



# Display image
cv2_imshow(image)
cv2.waitKey(0)

line_fn = np.poly1d(coeffs1+coeffs2)
x = np.linspace(600, 900, 100)
y = line_fn(x)
line_pts = np.stack((x, y)).T.astype(np.int32)

# Draw on existing image
cv2.polylines(image, [line_pts], False, (0,0,255), 2)



# Display image
cv2_imshow(image)
cv2.waitKey(0)

image = cv2.imread("/content/test2.png")
image.shape

def x_max(nums, x):
  nums.sort(reverse=True)
  return nums[x-1]
def x_min(nums, x):
  nums.sort(reverse=False)
  return nums[x-1]

block2

import cv2
import numpy as np
from scipy.optimize import curve_fit




x1 = [c[0] for c in block1]
x2 = [c[0] for c in block2]

c1 = x_max(x1,2)
c2 = x_min(x2,2)

# pt1 = (int(c1), 0)

pt1 = (int(c1), 0)
pt2 = (int(c2), image.shape[0])
cv2.line(image, pt1, pt2, (0,255,0), 2)

# Display
cv2_imshow(image)
cv2.waitKey()

image = cv2.imread("/content/test2.png")

def x_max(nums, x):
  nums.sort(reverse=True)
  return nums[x-1]
def x_min(nums, x):
  nums.sort(reverse=False)
  return nums[x-1]

coords = block1

# Extract x, y
x = [c[0] for c in coords]
y = [c[0] for c in coords]

# Get bounding points
x1 = min(x)
x2 = max(x)
y1 = min(y)
y2 = max(y)


# Plot points
# for i in range(len(x)):
#     cv2.circle(image,(x[i],y[i]), 5, (0,0,255), -1)

# Fit line to bounding points
m = (y2 - y1)/(x2 - x1)
b = y1 - m*x1

# Draw fitted line
pt1 = (int(x1), int(b))
pt2 = (int(x2), int(m*x2+b))
cv2.line(image, pt1, pt2, (0,255,0), 2)

# Display image
cv2_imshow(image)
cv2.waitKey(0)

img=image

# Get image size
h, w, _ = img.shape

# Calculate slope and intercept of line between points
m = (pt2[1] - pt1[1]) / (pt2[0] - pt1[0])
b = pt1[1] - m * pt1[0]

# Calculate x points to extend line
x1 = 0
x2 = w

# Calculate y points from line equation
y1 = int(m*x1 + b)
y2 = int(m*x2 + b)

# Draw extended line
cv2.line(img, (x1,y1), (x2,y2), (255,0,0), 2)

# Show result
cv2_imshow(img)
cv2.waitKey(0)